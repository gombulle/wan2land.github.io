---
layout: post
title: "'==' 연산자를 사용하면 안되는 이유"
date: 2016-03-21 18:48:40 +09:00
tags: ['php', 'syntax', 'equal', 'same']
---

보통 `==`를 사용하기보다는 `===`를 사용하라고 합니다.

왜 그럴까요?

**예시1. 0과 false 때문에 발생하는 문제.**

```php
<?php

'' == false; // true
false == 0; // true
0 == '0'; // true

'0' == ''; // false
```

**예시2. "0000"에서 발생하는 문제.**

```php
<?php

'0' == 0; // true
0 == '00000'; // true

'00000' == '0'; // false
```

**예시3. 해쉬 함수에서 생성되는 스트링에서 발생하는 문제.**

```php
<?php

$x = hash( ... );
echo $x; // "0eafafb392"

$x == 0; // true
'0e00' == '0e99'; // true
```

위 소스를 잠깐 설명하자면 해쉬함수는 보통 0~f까지로 구성된 문자열을 반환하는데,
이게 처음 시작이 `0e`로 시작하는 경우 "0"과 같다고 인식해버립니다. 왜냐하면
"float"로 인식하기 때문입니다. (실제로 저희 회사는 위 상황에서 버그가
발생했었습니다..;;)

즉, 그렇기 때문에 `==`를 사용하기보다는 `===`를 사용하는게 좋습니다.

## in_array

위 이야기를 조금 더 풀어서 하면 `in_array`라는 함수가 굉장히 문제가 될 수
있습니다.

```php
<?php
$x = ['0000', '0111', '1234'];

if (in_array('0e98', $x)) {
    echo "true!";
}
```

위 소스를 돌려보면 `true!`가 출력됩니다. `in_array`함수는 내부 변수를 찾을 때,
'=='을 기반으로 찾아내기 때문입니다. 그렇다면 이 부분을 개선하기 위해서는
어떻게 하면 좋을까요?

```php
<?php
$x = ['0000', '0111', '1234'];

if (in_array('0e98', $x, true)) {
    echo "true!";
}
```

아주 쉽습니다. 세번째 매개변수를 `true`를 주면 됩니다. 그러면 `in_array`는 이제
`==`가 아닌 `===`를 통해서 비교하게 됩니다.

## 그 외에 위와 같은 잠재적 위험성을 가진 함수

- `array_search`
- `array_unique` (flag 기본값일 때는 문제 없음.)
